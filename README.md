# MIPS Simulator

This is a suite of programs desgined to build and run assembly wriiten for a MIPS like architecture. Currently, it consists of :

* Assembler
* Virtual Machine (VM)
* Debugger
* A Graphical User Interface

See [Work In Progress](#work-in-progress) for programs that will be added in the future.

## Compiling

To compile from the source run:
```make program_name``` from the root directory of the repository.

The ```program_name``` can be one of the following:

* `assembler` for builing the assembler
* `vm` for building the VM
* `debugger` for building the debugger
* `app` for building the user interface

The user interface requires that you have `gtkmm-3.0` libraries present.

## Current State of the Project

### Assembler

The assembler currently supports the following instructions:

#### Arithmetic and Logical Operations

* sll
* addr
* addu
* subr
* subu
* and
* or
* xor
* nor
* andi
* ori
* xori
* addi
* addiu

#### Set instructions

* slt
* sltu
* slti
* sltiu

#### Load/Store Instructions

* lb
* lh
* lw
* lbu
* lhu
* sb
* sh
* sw

#### Branch and Jump Instructions

* beq
* jmp
* bne
* jal
* jr

The Assembler as of now checks for and generates errors in the input file, resolves branch address and generates output files.
It also evaluates constant expressions. So you can do stuff like

```addi $s0,$s1,2*3```

and the assembler will evaluate `2*3` to `6`. Currently it supports following operators:
 \+ \-, \*, /, <<, >> , &, | , ^ , ~
 The precedence of the << , >> , & and | are changed to have the same precedence as the multiply and divide operators.

 The binary file generated is a simple binary file with some headers and debug information. The headers provide information about certain aspects of the program that the machine should know as well as the debug info that allows the debugger to run. 

The assembler can be run from the UI as well as the command line. Errors are printed accordingly.

To use the assembler from the command line run :

```./assembler input_file -o output_path```

Currently the assembler treats all the files as if they were being assembled in debug mode.

The input file can be any kind of text file containing the code. The arguments to the assembler *must* be in the exact order as shown above.

### Virtual Machine

To run the vm :

```./vm input_file [-d] dump_file_path```

The `-d` argument will generate a dump file in `dump_file_path`. If no path is specified, the dump file is generated in the same directory as of the input file. The generated dump file has a `.dump` extensions and is a regular text file.

By default it runs with a memory of 1024 words ( 1024 * 32 bits ) and has a text area of 256 words. Therefore it can only run program whose length is less than 256 words.

The VM as of now supports all the instructions currently supported by the Assembler ( See [Instructions Supported](#arithmetic-and-logical-operations) ). The machine currently has no input and output functionality. The only way to view the output is to generate the dump file and view it in a text editor. The input has to be hard coded in your program code.

### Debugger

To run the debugger use:
```./debug input_file```

The `input_file` must be a binary file generated by the assembler with debug information.

The Debugger supports some simple debug operations: break, continue and step. It also allows you to view the registers and memory.

Similar to the assembler the  Debugger can be run from the command line as well as from the UI.

The commands for operations that the debugger currently supports are:

#### Creating Breakpoints

Command: ```break line_number```

Creates a breakpoint at the specified line number. The line must contain a valid instruction. Currently, we don't support breakpoints on labels.

#### Continue Execution

Command: ```continue```

Continues execution until we hit a breakpoint or the program ends.

#### Single Stepping

Command: ```step```

For single stepping through breakpoints and instructions.

#### Viewing registers

Command: ```registers```

Displays all of the general purpose registers

#### Viewing Memory locations

Command: ```mem start_address n```

Displays memory starting at `start_address` with `n` number of bytes. The memory is displayed in a hex format and is grouped into 32-bit chunks.

#### Resetting execution

Command: ```reset```

Resets the execution of the program preserving the breakpoints.

### The User Interface

The user interface is simple one that contains buttons for the kind of actions that you want to do.
It displays the general purpose registers, source code, errors generated during assembly as well as memory locations.

#### Open File

Opens an `.asm` or a `.bin` file. Opening a `.bin` file will load it in the debugger making it ready for execution. The `.asm` files have to be assembled first before they are ready for execution.

#### Assemble

Runs the assembler on the current file. The output `.bin` file has the same name as the input `.asm` file ( without the `.asm` extension ) and is generated in the same folder as that of the `.asm` file. The errors ( if any ) are displayed at the bottom pane with the relevant information.

#### Break

Create a breakpoint in the line that is currently selected. The line must contain a valid instruction.

#### Memory

The `Memory` button displays a dialog box that prompts the users to enter the starting address and the number of bytes to be displayed. The memory contents are displayed at the bottom pane along side the error tab.

The rest of the buttons behave exactly as the ones in the debugger.

## TODO List

### Assembler Features

* Add scaling to the load and save instructions so that proper byte alignment is maintained
* Add support for assembler directives/ preprocessing
* Add more instructions
* Improve error handling
* Allow I-type instrutions to support immediate value in either of the two operand fields. i,e. make both `addi $s0,$s0,12` and `addi $s0,12,$s0` valid.

### VM Features

* Add input/output functionality
* Allow for misaligned load/stores
* Improve error handling
* Make the machine self-sustaining.

### Debugger Features

* Add commands to view specific registers.
* Add support for breakpoints in lines that do not contain labels.

## Work in Progess

Nothing as of now.